#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     button,        sensorTouch)
#pragma config(Motor,  motorA,          left,          tmotorNXT, PIDControl, reversed, driveLeft, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          right,         tmotorNXT, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



void goStraight() {
	motor(left) = 20;
	motor(right) = 20;
}

void stopMoving() {
	motor(left) = 0;
	motor(right) = 0;
}

void moveToEnd() {
	motor(left) = 4;
	motor(right) = 4;
	wait1Msec(2100);
	motor(left) = 0;
	motor(right) = 0;
}

void turnRight() {
	motor[left] = 10;
	motor[right] = -10;
	wait1Msec(300);
	motor[left] = 0;
	motor[right] = 0;
}

void turnLeft() {
	motor[left] = -15;
	motor[right] = 15;
	wait1Msec(300);
	motor[left] = 0;
	motor[right] = 0;
}


task main()
{
	// Calibrate Light Readings
	while(SensorValue[button] == 0) {
		// Do nothing until button is pressed
	}
	wait1Msec(1000);
	// Get light reading for white
	int whiteReading = SensorValue[light];

	while(SensorValue[button] == 0) {
		// Do nothing
	}
	wait1Msec(1000);
	// Get light reading for black
	int blackReading = SensorValue[light];

	while(SensorValue[button] == 0) {
		// Do nothing
	}
	wait1Msec(1000);

	// Following Line Variables
	string state = "forward";
  int lightReading = SensorValue[light];
  int checkRightCounter = 0;
  int checkLeftCounter = 0;

	// Drawing Line Variables
	int direction[40]; // how many degrees to turn (negative for left, postiive for right)
	int distance[40]; // Distance to travel
	for (int i = 0; i < 40; i++) {
		direction[i] = 0;
		distance[i] = 0;
	}
	int index = 0; // To check what the previous direction was and to find the new direction

	// While button not pressed
	clearTimer(T1);
	while(SensorValue[button] == 0) {
		// Take light readings tenth of a second
		wait1Msec(100);
		lightReading = SensorValue[light];
		// If black go straight
		if (state == "forward") {
			checkRightCounter = 0;
			checkLeftCounter = 0;
			// If lightReading is around the white reading
			if (lightReading > whiteReading - 10) {
				distance[index] = time1[T1];
				stopMoving();

				state = "endOfPath";
				checkRightCounter = 0;
				checkLeftCounter = 0;
			}
			else {
				goStraight();
			}
		}
		else if (state == "endOfPath") {
			moveToEnd();
			state = "checkRight";
		}
		else if (state == "checkRight") {
			lightReading = SensorValue[light];
			// If path found
			if (lightReading < blackReading + 10) {
				motor[left] = 0;
				motor[right] = 0;
				// How many turns before path is found
				index = index + 1;
				direction[index] = checkRightCounter;
				clearTimer(T1);
				state = "forward";
			}
			// turn right at intervals until around 90 degrees
			else if (checkRightCounter < 12) {
				turnRight();
				checkRightCounter = checkRightCounter + 1;
			}
			else {
				state = "checkLeft";
			}
		}
		else if (state == "checkLeft") {
			lightReading = SensorValue[light];
			// If path found
			if (lightReading < blackReading + 5) {
				motor[left] = 0;
				motor[right] = 0;
				// how many degrees left before path is found
				index = index + 1;
				direction[index] = 8 - checkLeftCounter;
				clearTimer(T1);
				state = "forward";
			}
			// turn left 180
			else if (checkLeftCounter < 25) {
				turnLeft();
				checkLeftCounter = checkLeftCounter + 1;
			}
		}
	}

	motor(left) = 0;
	motor(right) = 0;
	wait1Msec(3000);

	// While button not pressed
	while(SensorValue[button] == 0) {
		// Do nothing
	}

	wait1Msec(3000);
	// Draw path until button pressed
	for (int i = 0; i < 40; i++) {
		if (distance[i] == 0) {
			// Do nothing
		}
		// there is a distance to travel
		else {
			int time = distance[i]/3;
			if (direction[i] > 0) {
				int counter = 0;
				while (counter!= direction[i]) {
					turnRight();
					counter = counter + 1;
				}
				// go straight
				goStraight();
				wait1Msec(time);
				stopMoving();
			}
			else if (direction[i] < 0) {
				int counter = 0;
				while(counter!= direction[i]) {
					turnLeft();
					counter = counter - 1;
				}
				// go straight
				goStraight();
				wait1Msec(time);
				stopMoving();
			}
			else {
				goStraight();
				wait1Msec(time);
				stopMoving();
			}
		}
	}

}
